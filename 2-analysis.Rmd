---
title: "Mining Impactful Discoveries 2: Analysis"
author: "Erwan Moreau"
date: "November 2021"
output:
 html_document:
    fig_width: 10
    fig_height: 4
---


```{r setup, include=FALSE}
library(knitr)
library(rmarkdown)
knitr::opts_chunk$set(echo = TRUE)
```


# medline-discoveries: analysis

## Overview

This document is part of the documentation for the [Medline Discoveries repository](https://github.com/erwanm/medline-discoveries), which is the companion code for the paper "Mining impactful discoveries from the biomedical literature" **TODO link**.

- [The main documentation](https://erwanm.github.io/medline-discoveries/1-detecting-surges.html) describes how to generate the output data (i.e. detecting surges) using the provided R implementation.
- This part of the documentation covers additional analysis of the results, including how the graphs and tables presented in the paper are obtained.

### Rmd Options

This document was generated from an [R Markdown](https://rmarkdown.rstudio.com/) source file. The source file is provided in the repository, allowing full reproducibility of the experiments presented in the paper. It can be executed through the RStudio interface ("knit" button) or as follows:

```
rmarkdown::render('1-detecting-surges.Rmd')
```

The `.Rmd` source document can be configured by modifying the following lines:

```{r myoptions}
# directory for the input data (Medline frequency data)
dataPathInput <- 'data/input'
dataPathInputStatic <- paste(dataPathInput,'static',sep='/')
# directory for the output data (extracted surges from the main process in step 1)
dataPathOutput <- 'data/output'
# filenames suffix (see 'input data format' below)
data.suffix <- '.ND.min100'
# set to TRUE for quick execution with a random subset of the data
shortVersion <- TRUE
# set to TRUE in order to save the graphs used in the paper
savePaperGraphs <- TRUE
```


```{r initialization}
source('discoveries.R')
```

## Requirements

The software requirements are the same as for [the first part](1-detecting-surges.html#software)

This part requires the same input data as in [the first part](1-detecting-surges.html#data), but also the output generated as a result of applying the process. Both datasets can be downloaded at **TODO link**.

By default the input data is expected in the subdirectory `data/input` and the output data (unsuprisingly)  in `data/output`.

## Loading


```{r load}
dynamic_joint <- loadDynamicData(dataPath,indivOrJoint = 'joint')
dynamic_indiv <- loadDynamicData(dataPath,indivOrJoint = 'indiv')
dynamic_total <- loadDynamicTotalFile(dataPath)
static_data <- loadStaticData(dataPathStatic)
```


## Selecting some of the specific concepts presented in the paper

```{r als}
als <- filterConcepts(dynamic_joint, 'D000690')
selectedALS <- filterConcepts(als,c('D051379','D000073885','D000870','D019782','D008875'))
parkinson <- filterConcepts(dynamic_joint, 'D010300')
caseParkinson <- filterConcepts(parkinson, 'D013378')
```

## Selecting a random subset

```{r, init.data.short, echo=shortVersion, eval=shortVersion}
dynamic_joint<-pickRandomDynamic(dynamic_joint,n=1000)
```

In order to avoid cases with insufficient data, it is possible to filter out rows with less than some minimum frequency $m$ (the relation must have at least one year with a frequency higher than $m$). It is also possible to specify the number of cases to pick:

```{r rnd2}
three_relations<-pickRandomDynamic(dynamic_joint,n=3, minFreqYear = 200)
```


## Displaying relations frequency across time with their concepts names

Using the relations selected randomly above:

```{r display1}
displaySeveralPairsData(relation,static_data,dynamic_total)
```


```{r display2}
displaySeveralPairsData(three_relations,static_data,dynamic_total)
```

## Displaying the ALS cases


```{r expl1}
g<-displaySeveralPairsData(selectedALS,static_data,dynamic_total,excludeConceptsFromName = 'D000690',ncol=5)
g
```

```{r expl1.save, echo=savePaperGraphs, eval=savePaperGraphs}
ggsave('expl1.pdf',g)
```

## Displaying measures

```{r measures1}
g <- displayMultiMeasure(selectedALS,dynamic_indiv,dynamic_total,static_data,windows=c(1,3,5),measures=c('prob.joint','pmi','npmi','mi','nmi'),excludeConceptsFromName = 'D000690')
g
```


```{r measures1.save, echo=savePaperGraphs, eval=savePaperGraphs}
ggsave('expl-measures.pdf',g+ theme(text=element_text(size=14),legend.position="none",axis.title.x=element_blank(),axis.title.y=element_blank()),width=20,height=16,units = "cm")
```

## Study of the trend parameters

### Using simple frequency, indicator 'rate'

```{r trend1}
displayMultiTrend(selectedALS,dynamic_indiv,dynamic_total,static_data,indicator='rate',measure = 'prob.joint',excludeConceptsFromName = 'D000690')
```

### Using NMI, indicator 'rate'

```{r trend2}
displayMultiTrend(selectedALS,dynamic_indiv,dynamic_total,static_data,indicator='rate',measure = 'nmi',excludeConceptsFromName = 'D000690')
```

### Using NMI, indicator 'diff'

```{r trend3}
displayMultiTrend(selectedALS,dynamic_indiv,dynamic_total,static_data,indicator='diff',measure = 'nmi',excludeConceptsFromName = 'D000690')
```


## Examples for indicators and surges

### Using simple frequency

```{r surges1}
g <- displaySurges(caseParkinson,dynamic_indiv,dynamic_total,static_data,windows=c(1,3), indicators=c('rate','diff'),withTitle = TRUE)
g
```

### Using NMI

```{r surges2}
g <- displaySurges(caseParkinson,dynamic_indiv,dynamic_total,static_data,valueCol='nmi',windows=c(1,3,5), indicators=c('rate','diff'),withTitle = TRUE)
g
# saving the graph as pdf:
# ggsave('expl1.pdf',g)
```

## Displaying the trend distribution

### 'Standard' version


```{r sample.ma}
relations.ma <- computeMovingAverage(dynamic_joint,dynamic_total, window=5)
indiv.ma <- computeMovingAverage(dynamic_indiv,dynamic_total, window=5)
```

The following graphs show different versions of the histogram of the `trend` values: with/without logarithmic scale on the X and/or Y axis.

The vertical lines show the outlier threshold calculated as $Q_3+k \times IQR$, where $k$ is either 1.5 or 3 ("far outliers").

```{r trend.distrib1}
#l<-displayTrendDistribution1(relations.ma,indiv.ma)
#l$x0.y0
#l$x0.y1
#l$x1.y0
#l$x1.y1
```

### Quantile plot ("flat" distribution)

These graphs show the "flat" distribution (probably not a standard name): 

- The points are sorted by `trend` and their relative rank (rank divided by number of points) is plotted as X. In other words, the X axis represents all the quantile positions with respect to `trend`.
- The `trend` value shown on the Y axis is normalized between [0,1] for every measure.

```{r trend.distrib3}
#displayTrendDistribution2(relations.ma,indiv.ma,withRect = FALSE)
g<-displayTwoPlotsDistribTrend(relations.ma,indiv.ma)
g
```

```{r trend.distrib3.save, echo=savePaperGraphs, eval=savePaperGraphs}
ggsave('expl-trend-distrib.pdf',g,width=20,height=8,units = "cm")
```


## Evaluation 

## Gold standard data

TODO

```{r gold}
gold <- loadGoldDiscoveries(todo)
```

## Parameters


```{r eval}
res.eval<-evalSurgessAgainstGold(gold,'data/21-extract-discoveries/recompute-with-ND-group/MED',evalAt=NA)
```

### Top individual configurations

```{r eval.params.indiv}
eval3 <- res.eval[eval.window==3 & mode=='first.year',]

```

### Comparison by parameter


```{r eval.params.plot}
g<-displayAvgPerfByParam(rr,evalWindow = 3)
g
```

```{r, echo=savePaperGraphs, eval=savePaperGraphs}
ggsave('plot-params.pdf',g,width = 20,height=8,unit='cm')
```


### Overlap by pair of configurations

The overlap coefficient is calculated based on the number of relations in common between the two configurations, where "in common" means that the relation appears in both lists with their surge year within 5 years of each other.  

* Note: in the code below the window of years (5) can be set to NA. In this case the overlap coefficient is only based on relations in common (no year comparison).

```{r eval.overlap}
d<-readMultipleSurgesFiles(measures=c('prob.joint','nmi','npmi','scp','pmi','mi'),indicator='diff')
mat<-correlationMatrixMultiParam(d, 5)
g<-heatMapCommonMatrix(mat)
g
```

```{r eval.overlap.save, echo=savePaperGraphs, eval=savePaperGraphs}
ggsave('heatmap-overlap.pdf',g,width=20,height=15,unit='cm')

```

## Distribution of surges across time

```{r eval.years}
g<-plotSurgesAcrossTime(bins=68,fontsize=16)
```

```{r eval.years.save, echo=savePaperGraphs, eval=savePaperGraphs}
ggsave('surges-by-year.pdf',g,width=20,height=12,unit='cm')
```