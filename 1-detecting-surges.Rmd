---
title: "Mining Impactful Discoveries 1: Detecting Surges"
author: "Erwan Moreau"
date: "November 2021"
output: html_document
---


```{r setup, include=FALSE}
library(knitr)
library(rmarkdown)
library(ggplot2)
source('discoveries4.R')
knitr::opts_chunk$set(echo = TRUE)
# TODO temporary path
dataPath <- '../data/21-extract-discoveries/recompute-with-ND-group/MED'
dataPathStatic <- paste(dataPath,'across-all-years',sep='/')
```


# Preparing the input data

The initial raw data is extracted from the Medline database using the ... KD, tdc tools, steps  

TODO

# Loading the input data



```{r load dynamic}
dynamic_joint <- loadDynamicData(dataPath,indivOrJoint = 'joint')
# TEMPORARY FOR TESTS
dynamic_joint <- head(dynamic_joint,200000)
dynamic_indiv <- loadDynamicData(dataPath,indivOrJoint = 'indiv')
dynamic_total <- loadDynamicTotalFile(dataPath)
```

## Statistics

* Number of concepts:

```{r}
nrow(unique(dynamic_indiv,by=key(dynamic_indiv)))
```

* Number of relations:

```{r}
nrow(unique(dynamic_joint,by=key(dynamic_joint)))
```

* Number of rows, i.e. pairs (relation,year):

```{r nrow1}
nrow(dynamic_joint)
```



# Preprocessing

This step fills the gap years with 0 frequency values and calculates the moving average if needed.

- This step is necessary even if the moving average is not used (default window of size 1).

With a moving average over a window of size 5:

```{r ma5}
relations.ma <- computeMovingAverage(dynamic_joint,dynamic_total, window=5)
indiv.ma <- computeMovingAverage(dynamic_indiv,dynamic_total, window=5)
```

New size:

```{r nrow2}
nrow(relations.ma)
```


# Caculating a set of measures by year

In this the measure used as a basis for calculating the trend (next step) is calculated. 

Available measures:

* `prob.joint` is the simple joint probability (it is already calculated from the previous step but this step is still recommended for consistency).
* `pmi` and `npmi`: [Pointwise Mutual Information](https://en.wikipedia.org/wiki/Pointwise_mutual_information) and its normalized variant.
* `mi` and `nmi`: "binary" [Mutual Information](https://en.wikipedia.org/wiki/Mutual_information) and its normalized variant. The events considered are simply based on whether each concept is present or not (hence the word "binary").
* `scp`
* `pmi2` and `pmi3`

```{r measures}
rel.mesures<-addDynamicAssociationToRelations(relations.ma,indiv.ma,measures = c('prob.joint','pmi','nmi'))
```

# Calculating the trend for every year and every relation

This step calculates the `trend` for every year and every relation, then labels each year as a surge or not (column `surge`). 

- The input data table is modified in place for the sake of efficiency. It contains additional columns after executing the function, but the number of rows is not modified. 
- The trend is calculated on the column provided with the argument `measure`.
- The `indicator` argument determines how the `trend` value is calculated:
    - `rate` (default) is the relative rate: $\frac{p_{y}-p_{y-1}}{p_{y-1}}$
    - `diff` is the difference: $p_{y}-p_{y-1}$

Example:

```{r trend}
computeTrend(rel.mesures, indicator='rate', measure='nmi')
```

- Note: there is no need to store the output data table since `relations` is modified by reference.

# Detecting surges

For every relation, this step labels filters the years which have a finite `trend` value and labels the remaining rows as surge or not (column `surge` added). 

A surge is defined as a year where the `trend` is an [upper outlier](https://en.wikipedia.org/wiki/Interquartile_range#Outliers), i.e. if the values is higher than the third quartile plus 1.5 times the inter quartile range (IQR). There are two options for calculating the outlier years:

- Local outliers (default): every relation is processed independently, i.e. the Q3+1.5IQR threshold is calculated based on the trend values for the current relation only. In other words, the surge years are outliers for the current relation only.
- Global outliers: the Q3+1.5IQR threshold is calculated based on the trend values for the whole dataset. In other words, the surge years are outliers globally.
- The input data table is modified in place for the sake of efficiency. 


```{r surges}
detectSurges(rel.mesures, globalOutliers=FALSE)
```


## Statistics local surges


```{r}
local_stats <- countSurgesByRelation(local_surges)
kable(local_stats[n.surges<=10,])
```

### Statistics global surges

```{r}
global_stats <- countSurgesByRelation(global_surges)
kable(global_stats[n.surges<=10,])
```

```{r}
local_stats[,surge.type:='local']
global_stats[,surge.type:='global']
full_stats <- rbind(local_stats,global_stats)
ggplot(full_stats,aes(n.surges,prop))+geom_col()+facet_grid(.~surge.type)
```


# Processing multiple parameters and saving surges data


A convenience function is provided which computes the surges based on multiple parameters and saves the resulting data to a file. This function encapsulates all the steps presented above.

```{r saving}
#computeAndSaveSurgesData(dataPath,outputFilePrefix=paste0(dataPath,'/'), #ma_windows=c(1,3,5),indicators=c('prob.rate','prod.log'), outlier_methods=c('local','global'))
```
