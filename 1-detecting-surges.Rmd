---
title: "Mining Impactful Discoveries 1: Detecting Surges"
author: "Erwan Moreau"
date: "November 2021"
output: html_document
---


```{r setup, include=FALSE}
library(knitr)
library(rmarkdown)
library(ggplot2)
source('discoveries4.R')
knitr::opts_chunk$set(echo = TRUE)
# TODO temporary path
dataPath <- '../data/21-extract-discoveries/recompute-with-ND-group/MED'
dataPathStatic <- paste(dataPath,'across-all-years',sep='/')
# set to TRUE for short execution with a subset of data
shortVersion <- TRUE
```


# Preparing the input data

The initial raw data is extracted from the Medline database using the ... KD, tdc tools, steps  

TODO

# Loading the input data



```{r load dynamic}
dynamic_joint <- loadDynamicData(dataPath,indivOrJoint = 'joint')
dynamic_indiv <- loadDynamicData(dataPath,indivOrJoint = 'indiv')
dynamic_total <- loadDynamicTotalFile(dataPath)
```

```{r, init.data.short, eval=shortVersion}
dynamic_joint<-pickRandomDynamic(dynamic_joint,n=1000)
```



## Statistics

* Number of concepts:

```{r}
nrow(unique(dynamic_indiv,by=key(dynamic_indiv)))
```

* Number of relations:

```{r}
nrow(unique(dynamic_joint,by=key(dynamic_joint)))
```

* Number of rows, i.e. pairs (relation,year):

```{r nrow1}
nrow(dynamic_joint)
```



# Preprocessing

This step fills the gap years with 0 frequency values and calculates the moving average if needed.

- This step is necessary even if the moving average is not used (default window of size 1).

With a moving average over a window of size 5:

```{r ma5}
relations.ma <- computeMovingAverage(dynamic_joint,dynamic_total, window=5)
indiv.ma <- computeMovingAverage(dynamic_indiv,dynamic_total, window=5)
```

New size:

```{r nrow2}
nrow(relations.ma)
```


# Caculating a set of measures by year

In this the measure used as a basis for calculating the trend (next step) is calculated. 

Available measures:

* `prob.joint` is the simple joint probability (it is already calculated from the previous step but this step is still recommended for consistency).
* `pmi` and `npmi`: [Pointwise Mutual Information](https://en.wikipedia.org/wiki/Pointwise_mutual_information) and its normalized variant.
* `mi` and `nmi`: "binary" [Mutual Information](https://en.wikipedia.org/wiki/Mutual_information) and its normalized variant. The events considered are simply based on whether each concept is present or not (hence the word "binary").
* `scp`
* `pmi2` and `pmi3`

```{r measures}
rel.measures<-addDynamicAssociationToRelations(relations.ma,indiv.ma,measures = c('prob.joint','pmi','nmi'))
```

# Calculating the trend for every year and every relation

This step calculates the `trend` for every year and every relation, then labels each year as a surge or not (column `surge`). 

- The input data table is modified in place for the sake of efficiency. It contains additional columns after executing the function, but the number of rows is not modified. 
- The trend is calculated on the column provided with the argument `measure`.
- The `indicator` argument determines how the `trend` value is calculated:
    - `rate` (default) is the relative rate: $\frac{p_{y}-p_{y-1}}{p_{y-1}}$
    - `diff` is the difference: $p_{y}-p_{y-1}$

Example:

```{r trend}
computeTrend(rel.measures, indicator='diff', measure='nmi')
```

- Note: there is no need to store the output data table since `relations` is modified by reference.

# Detecting surges

For every relation, this step marks the years where the trend value is higher than some threshold $t$ as surge. 
TODO update

- $t$ can be a custom threshold or defined based on the standard outlier threshold calculated with the inter-quartile range: $t=Q_3 + 3 IQR$. 
- $t$ can be calculated locally, i.e. independently for every every concept/pair (default)
- $t$ can be defined globally, either with a custom value or using the standard outlier threshold.
- The input data table is modified in place for the sake of efficiency. 


```{r surges}
# threshold <- calculateThresholdTopOutliers(rel.measures$trend)
threshold <- calculateThresholdInflectionPoint(rel.measures$trend)
print(threshold)
detectSurges(rel.measures, globalThreshold=threshold)
```


# Adjusting the surge year in the sliding window

Using a moving average window (size higher than 1) can cause the surge year to be detected too early. This can lead to a meaningless result, in particular if the surge year may have zero cooccurrences. This step performs a simple adjustment to the next year with non-zero frequency in cases where this problem happens.

```{r adjust}
adjustZeroFreqSurges(rel.measures,window=5)
```


# Statistics surges


```{r}
surges_stats <- countSurgesByRelation(rel.measures)
kable(surges_stats[n.surges<=10,])
```


```{r}
ggplot(surges_stats,aes(n.surges,prop))+geom_col()
```


# Processing multiple parameters and saving surges data


A convenience function is provided which computes the surges based on multiple parameters and saves the resulting data to a file. This function encapsulates all the steps presented above.

```{r saving,eval=!shortVersion}
system.time(computeAndSaveSurgesData(dataPath,outputFilePrefix=paste0(dataPath,'/'), ma_windows=c(1,3,5),indicators=c('rate','diff'), outlier_methods=c('local','global')))
```
